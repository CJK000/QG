# QG训练营数据挖掘组第四周周记：2019年4月14日

## 生活随记

### 4/8 - 4/10 

做上周还没做完的事。

### 4/11 周四

我也忘记做了啥了

### 4/12 周五

这周训练营大组培训的时间是从训练营开始到现在最长的一次了，接近一个小时，详细讲解了代码复杂度的分析方法和多种排序算法。

#### 评估算法的时间复杂度 (大O记法)

##### 表示方法

算法的时间复杂度用 符号O 表示
O(n)：其中n为数据输入量，这里表示算法的用时与输入量成正比，代表着一个算法的最坏情况的运行时间（上界）

##### 计算方法

只有常数项的都记为O(1)，如O(4) = O(1)
只保留最高阶项，如O(n3 + 4n2) = O(n3)
如果最高阶项的系数不是1，则将该系数改为1
	如O(4n3 + n2) = O(n3)

![1555251333573](C:\Users\岑\AppData\Roaming\Typora\typora-user-images\1555251333573.png)

##### 特点

大O记法对数据量大的时候才会体现优势，并且丢失了原函数的一些信息，如：T（n）=n+10000对应O（n）

#### 排序算法

##### 插入排序

从左到右遍历所有数据，确定并拿出需要插入的值，然后将左边比它大的值全部右移，最后将值插入的正确位置上。

##### 分治法（排序思想）

将原问题分解成若干个规模较小的，类似于原问题的子问题，递归求解，合并这些解。

##### 归并排序

归并排序的核心思想是递归与合并操作

递归：不断将一个子序列（包含原序列本身）拆分成近似相等的两份，直到无法再拆分。

一次合并：将两个有序序列合并为一个有序序列

##### 快速排序

快速排序的核心思想是递归与划分操作

一次划分：选择某个元素作为枢纽，然后将比它小的放左边，比它大的放右边，最后可以确定枢纽有序时的所在位置。

##### 计数排序

计数排序是非比较式排序，通过收集、统计和分配来进行排序

收集：计算每种值的元素个数

统计：计算小于等于该值的元素个数

分配：将所有元素按收集表分配到对应位置，分配前需将表上对应的值减1（倒序进行）

##### 基数计数排序（桶排序）

基数计数排序使用容量更小（为10）的桶进行收集统计，但需要进行多趟的计数排序。

不需要进行值的比较和交换，是稳定排序

##### 颜色排序（只存放数组0、1、2的数组）

方法：使用两个索引控制0和2的放置位置，再用一个索引进行遍历，遇到0或2时与索引对应位置进行交换，并再检查一次交换过来的值是否需要再放置，直到p与p2相遇则结束

##### 在一个无序序列中找到第K大/小的数

方法：使用快排中的划分法使我们可以在时间复杂度O（nlgn）的情况下找到特定排位的数。（快排每排完一次就判断枢纽元素所在位置是不是第K大/小的数，如果是直接输出，如果不是再根据要找元素所在区间使用快排循环这个过程）

### 4/13 周六

写代码，创建动态二维数组应该这样申请内存空间：

```c
int (*a)[size];
a = (int (*)[BIG])malloc(sizeof(int)*BIG*size);
```

#### 4/14 周日

周六基本上把函数写完了，今天写测试程序，又一次高估了自己，竟然想只花一个钟写完，写过写了一个下午加晚上还写到自闭了没写完，对大量数据进行测试的那个程序还没写出来，还不知道哪里思考错了。

### 一周总结

实在想不通的问题就先放一边吧，可能过一会放松心情了再拿起来思路更清晰。

调试很久的代码还是没写对，重构会是更好的选择。

### 存在问题

还是时间安排

### 下周规划

下苦功把小组作业做出来先，不然下周就不用写周记了。